<?php
// $Id$

/**
 * @file
 * Allows to send messages to all members of a role.
 */

/**
 * Implements hook_perm().
 */
function user_relationship_privatemsg_perm() {
  return array('write privatemsg to relationships', 'view relationship recipients');
}

function user_relationship_privatemsg_theme() {
  return array(
    'user_relationship_privatemsg_format' => array(
      'arguments' => array('relationship' => NULL, 'options' => array()),
    ),
  );
}

/**
 * Implements hook_privatemsg_recipient_types_info().
 */
function user_relationship_privatemsg_privatemsg_recipient_type_info() {
  $types = user_relationships_types_load();

  // If there is no relationship defined, don't expose it as a recipient type.
  if (empty($types)) {
    return;
  }

  return array(
    'user_relationship' => array(
      'name' => t('User relationship'),
      'description' => t('Enter the name of a user relationship to write a message to all related users. Example: %example.', array('%example' => reset($types)->plural_name)),
      'format' => 'user_relationship_privatemsg_format',
      'load' => 'user_relationship_privatemsg_load_multiple',
      'autocomplete' => 'user_relationship_privatemsg_autocomplete',
      'generate recipients' => 'user_relationship_privatemsg_load_recipients',
      'count' => 'user_relationship_privatemsg_count_recipients',
      'write callback' => 'user_relationship_privatemsg_check_write_access',
      'view access' => 'view relationship recipients',
    ),
  );
}

function user_relationship_privatemsg_check_write_access($relationship = NULL) {
  global $user;
  // Users are only allowed to write their own related users.
  if ($relationship) {
    if (!isset($relationship->account)) {
      $author = db_result(db_query('SELECT author FROM {user_relationship_privatemsg} WHERE urpid = %d', $relationship->recipient));
      $relationship->account = privatemsg_user_load($author);
    }
    if ($relationship->account->uid != $user->uid) {
      return FALSE;
    }
  }
  return user_access('write privatemsg to relationships');
}

/**
 * Format a relationship for displaying as recipient.
 */
function theme_user_relationship_privatemsg_format($relationship) {
  global $user;
  if ($relationship->account->uid == $user->uid) {
    return t('Your %relationship (relationship)', array('%relationship' => $relationship->plural_name));
  }
  return t('%relationship of !username (relationship)', array('%relationship' => $relationship->plural_name, '!username' => theme('username', $relationship->account)));
}

/**
 * Load relationships based on their rtid.
 */
function user_relationship_privatemsg_load_multiple($urpids) {
  global $user;
  $relationships = array();
  $result = db_query('SELECT * FROM {user_relationship_privatemsg} WHERE urpid IN (' . db_placeholders($urpids) . ')', $urpids);
  while ($row = db_fetch_object($result)) {
    if ($relationship = user_relationships_type_load($row->rtid)) {
      $relationship->type = 'user_relationship';
      $relationship->recipient = $row->urpid;
      $relationship->account = privatemsg_user_load($row->author);
      $relationships[privatemsg_recipient_key($relationship)] = $relationship;
    }
  }
  return $relationships;
}

/**
 * Returns the recipient id for a rtid - author combination.
 */
function _user_relationship_privatemsg_get_recipient_id($rtid, $uid) {
  if ($urpid = db_result(db_query('SELECT urpid FROM {user_relationship_privatemsg} WHERE rtid = %d AND author = %d', $rtid, $uid))) {
    return $urpid;
  }
  db_query('INSERT INTO {user_relationship_privatemsg} (rtid, author) VALUES (%d, %d)', $rtid, $uid);
  return db_last_insert_id('user_relationship_privatemsg', 'urpid');
}

/**
 * Load a number of recipient user ids.
 */
function user_relationship_privatemsg_load_recipients($relationship, $limit, $offset) {
  $recipients = array();
  $relationships = user_relationships_load(array('user' => $relationship->account->uid, 'rtid' => $relationship->rtid), array('limit' => $offset > 0 ? "$limit OFFSET $offset" : $limit));
  foreach ($relationships as $row) {
    if ($row->requester_id == $relationship->account->uid) {
      $recipients[] = $row->requestee_id;
    }
    else {
      $recipients[] = $row->requester_id;
    }
  }
  return $recipients;
}

/**
 * Return the number of users to which the author is related.
 */
function user_relationship_privatemsg_count_recipients($relationship) {
  $count_query = 'SELECT I AS count FROM {user_relationships} ur INNER JOIN {user_relationship_types} urt USING ( rtid ) WHERE (ur.requester_id = %d OR ((ur.approved <> 1 OR urt.is_oneway <> 0) AND ur.requestee_id = %d)) AND %s.%s = %d';
  return user_relationships_load(array('user' => $relationship->account->uid, 'rtid' => $relationship->rtid), array('count' => TRUE));
}

/**
 * Return relationship autocomplete suggestions.
 */
function user_relationship_privatemsg_autocomplete($fragment, $names, $limit) {
  $query = _privatemsg_assemble_query(array('autocomplete_roles', 'user_relationship_privatemsg'), $fragment, $names);
  $result = db_query_range($query['query'], $fragment, 0, $limit);
  $matches = array();
  while ($role = db_fetch_object($result)) {
    $matches[$role->plural_name] = $role->plural_name;
  }
  return $matches;
}

/**
 * Implements hook_privatemsg_name_lookup().
 */
function user_relationship_privatemsg_privatemsg_name_lookup($string) {
  global $user;
  $relationship = str_replace(t('[user_relationship]'), '', $string);
  if ($recipient = user_relationships_type_load(array('plural_name' => $relationship))) {
    $recipient->type = 'user_relationship';
    $recipient->recipient = _user_relationship_privatemsg_get_recipient_id($recipient->rtid, $user->uid);
    $recipient->account = $user;
    return $recipient;
  }
}

/**
 * Query definition to search for username autocomplete suggestions.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $search
 *   Which search string is currently searched for.
 * @param $names
 *   Array of names not to be used as suggestions.
 */
function user_relationship_privatemsg_sql_autocomplete_roles(&$fragments, $search, $names) {
  $fragments['primary_table'] = '{user_relationship_types} urt';
  $fragments['select'][] = 'urt.plural_name';

  // Escape the % to get it through the placeholder replacement.
  $fragments['where'][] = "urt.plural_name LIKE '%s'";
  $fragments['query_args']['where'][] = $search .'%%';
  if (!empty($names)) {
    // If there are already names selected, exclude them from the suggestions.
    $fragments['where'][] = "urt.plural_name NOT IN (". db_placeholders($names, 'text') .")";
    $fragments['query_args']['where'] += $names;
  }
  $fragments['order_by'][] = 'urt.plural_name ASC';
}
